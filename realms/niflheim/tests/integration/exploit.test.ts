/**
 * Niflheim Integration Test: Exploit Path (M9 Updated)
 * 
 * Tests the A10:2025 Exceptional Conditions vulnerability.
 * 
 * M9 Update: The vulnerability now triggers crash report generation instead of
 * directly exposing the flag. Crash reports contain diagnostic info with hints
 * to Helheim (realm chaining).
 */

interface ApiResponse {
  error?: string;
  message?: string;
  systemState?: {
    pressure: number;
    temperature: number;
    flowRate: number;
    doorStatus: string;
    timestamp: string;
  };
  diagnosticsAvailable?: boolean;
  crashReportId?: string;
  downloadUrl?: string;
  errorCode?: string;
  [key: string]: unknown;
}

// These tests require running services - skip if TEST_BASE_URL not set
const runIntegrationTests = process.env.TEST_BASE_URL || process.env.RUN_INTEGRATION_TESTS;

(runIntegrationTests ? describe : describe.skip)('Niflheim Exploit Path', () => {
  const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:8080/realms/niflheim';

  describe('A10:2025 - Exceptional Conditions Vulnerability (M9)', () => {
    it('should trigger crash report when pressure exceeds limit', async () => {
      const response = await fetch(`${BASE_URL}/api/regulate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pressure: 15000, temperature: -200, flowRate: 50 }),
      });

      expect(response.status).toBe(500);
      const data = await response.json() as ApiResponse;
      
      expect(data.error).toBe('CRITICAL_SYSTEM_FAILURE');
      expect(data.diagnosticsAvailable).toBe(true);
      expect(data.crashReportId).toBeDefined();
      expect(data.downloadUrl).toContain('/api/crash-report/');
      expect(data.errorCode).toBe('PRESSURE_OVERFLOW');
    });

    it('should trigger crash report when temperature is too low', async () => {
      const response = await fetch(`${BASE_URL}/api/regulate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pressure: 500, temperature: -600, flowRate: 50 }),
      });

      expect(response.status).toBe(500);
      const data = await response.json() as ApiResponse;
      
      expect(data.error).toBe('CRITICAL_SYSTEM_FAILURE');
      expect(data.errorCode).toBe('TEMPERATURE_UNDERFLOW');
    });

    it('should trigger crash report when flow rate exceeds limit', async () => {
      const response = await fetch(`${BASE_URL}/api/regulate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pressure: 500, temperature: -200, flowRate: 99999 }),
      });

      expect(response.status).toBe(500);
      const data = await response.json() as ApiResponse;
      
      expect(data.error).toBe('CRITICAL_SYSTEM_FAILURE');
      expect(data.errorCode).toBe('FLOW_RATE_EXCEEDED');
    });

    it('should reject non-numeric values with 400 error', async () => {
      const response = await fetch(`${BASE_URL}/api/regulate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pressure: 'not-a-number', temperature: -200, flowRate: 50 }),
      });

      expect(response.status).toBe(400);
      const data = await response.json() as ApiResponse;
      
      expect(data.error).toBe('Invalid input');
    });
  });

  describe('Normal Operation (Non-Exploit)', () => {
    it('should handle valid parameters without errors', async () => {
      const response = await fetch(`${BASE_URL}/api/regulate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pressure: 500, temperature: -200, flowRate: 50 }),
      });

      expect(response.status).toBe(200);
      const data = await response.json() as ApiResponse;
      
      expect(data.message).toBeDefined();
      expect(data.systemState).toBeDefined();
      expect(data.error).toBeUndefined();
    });

    it('should fetch system status successfully', async () => {
      const response = await fetch(`${BASE_URL}/api/status`);
      
      expect(response.status).toBe(200);
      const data = await response.json() as ApiResponse;
      
      expect(data.systemState?.pressure ?? (data as any).pressure).toBeDefined();
      expect(data.systemState?.doorStatus ?? (data as any).doorStatus).toBeDefined();
    });
  });

  describe('Network Isolation', () => {
    it('should not be accessible via direct port 3000', async () => {
      // Attempt to access realm directly (should fail due to Docker network isolation)
      try {
        await fetch('http://niflheim:3000/health', {
          signal: AbortSignal.timeout(2000),
        });
        // If we get here, isolation is broken
        fail('Realm should not be accessible via direct port');
      } catch (error) {
        // Expected: connection refused or timeout
        expect(error).toBeDefined();
      }
    });
  });
});
